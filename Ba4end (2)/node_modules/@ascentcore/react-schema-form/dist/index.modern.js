import React, { useState, useEffect, Fragment } from 'react';
import Ajv from 'ajv';

const SCHEMA_KEYWORDS = {
  PROPERTIES: 'properties',
  REQUIRED: 'required',
  CONST: 'const',
  IF: 'if',
  BOOLEAN: 'boolean',
  NUMBER: 'number',
  INTEGER: 'integer',
  ARRAY: 'array',
  OBJECT: 'object',
  STRING: 'string',
  MULTIPLE_ENUM: 'multipleEnum',
  ENUM: 'enum',
  FILE: 'file',
  BUTTON: 'button',
  REMOVE_BUTTON: 'removeButton',
  ADD_BUTTON: 'addButton'
};

const isObject = item => {
  return item && typeof item === SCHEMA_KEYWORDS.OBJECT && !Array.isArray(item);
}; //merges the current object at all nesting levels with a new one
//the method does not return a new object; the current one is being altered

const addProperties = (currentObject, newProperties) => {
  if (isObject(currentObject) && isObject(newProperties)) {
    for (const key in newProperties) {
      if (isObject(newProperties[key])) {
        if (!currentObject[key]) {
          Object.assign(currentObject, {
            [key]: {}
          });
        }

        addProperties(currentObject[key], newProperties[key]);
      } else {
        if (key === SCHEMA_KEYWORDS.REQUIRED && Array.isArray(newProperties[key]) && Array.isArray(currentObject[key])) {
          //@ts-ignore
          currentObject[key] = [...new Set(currentObject[key].concat(...newProperties[key]))];
        } else {
          Object.assign(currentObject, {
            [key]: newProperties[key]
          });
        }
      }
    }
  }
}; //gets all conditionals specified at root level of a schema;
//conditionals that are both specified with simple ifs, or as a list with allOf, anyOf, oneOf

const getConditionals = schema => {
  let ifEntries = [];
  const simpleConditional = getSimpleConditional(schema);

  if (simpleConditional) {
    ifEntries.push(simpleConditional);
  }

  ifEntries = ifEntries.concat(getMultipleConditionals(schema));
  const compiledIfEntries = ifEntries.map(ifEntry => getCompiledConditional(ifEntry));
  let compiledDependencies = [];

  if (schema.dependencies) {
    compiledDependencies = getCompiledDependencies(schema.dependencies);
  }

  return compiledIfEntries.concat(compiledDependencies);
}; //given a schema, the function will return a list with all the paths of the schema and the value of the leaf node
//keywords such as properties and const are not included
//usage: extract all the conditions specified inside an if statement

const getPropertyPathsIfStatement = (schema, path = '') => {
  if (isObject(schema)) {
    return Array.prototype.concat.apply([], Object.keys(schema).map(key => getPropertyPathsIfStatement(schema[key], key === SCHEMA_KEYWORDS.PROPERTIES || key === SCHEMA_KEYWORDS.CONST ? path : path + '.' + key)));
  } else {
    return [{
      '0': path,
      '1': schema
    }];
  }
}; //extract conditional from a simple if statement


const getSimpleConditional = schema => {
  if (schema.if && schema.if.properties) {
    return {
      if: getPropertyPathsIfStatement(schema.if),
      then: schema.then,
      else: schema.else
    };
  } else {
    return null;
  }
}; //extract conditionals from array


const extractConditionalFromArray = conditionalSet => {
  return conditionalSet.filter(entry => entry.if !== undefined).map(conditional => {
    return {
      if: getPropertyPathsIfStatement(conditional.if),
      then: conditional.then,
      else: conditional.else
    };
  });
}; //extract conditionals from allOf, anyOf, oneOf statements


const getMultipleConditionals = schema => {
  let multipleConditionals = [];

  if (schema.allOf) {
    multipleConditionals = multipleConditionals.concat(extractConditionalFromArray(schema.allOf));
  }

  if (schema.anyOf) {
    multipleConditionals = multipleConditionals.concat(extractConditionalFromArray(schema.anyOf));
  }

  if (schema.oneOf) {
    multipleConditionals = multipleConditionals.concat(extractConditionalFromArray(schema.oneOf));
  }

  return multipleConditionals;
}; //constructs string function which will be compiled when needed;
//rewrites the condition under an if statement as a function


const getCompiledConditional = ifEntry => {
  const compiled = `data => { return (${ifEntry.if.reduce((memo, item) => {
    return memo.concat(['data' + item[0] + '==' + (typeof item[1] === SCHEMA_KEYWORDS.STRING ? "'" + item[1] + "'" : item[1])]);
  }, []).join(' && ')}) || (${ifEntry.if.reduce((memo, item) => {
    return memo.concat(['data' + item[0] + '==' + 'undefined']);
  }, []).join(' && ')}) }`;
  return {
    compiled: compiled,
    ...(ifEntry.then ? {
      then: ifEntry.then
    } : {}),
    ...(ifEntry.else ? {
      else: ifEntry.else
    } : {})
  };
};

const getCompiledDependencies = dependencies => {
  return Object.entries(dependencies).map(dependency => {
    const compiled = `data => { return (data.${dependency[0]} !== undefined) }`;
    return {
      compiled: compiled,
      ...(Array.isArray(dependency[1]) ? {
        then: {
          required: dependency[1]
        }
      } : {
        then: dependency[1]
      })
    };
  });
};

const _ = require('lodash');

function FormElement({
  root,
  parentSchema,
  schema,
  path,
  value,
  errors,
  error,
  handleParentChange,
  registry,
  wrapper,
  config
}) {
  const [nestedSchema, setNestedSchema] = useState(null);
  useEffect(() => {
    function processRef($ref) {
      const def = $ref.substr($ref.lastIndexOf('/') + 1);
      return root.definitions[def];
    }

    function initializeData() {
      if (value === undefined) {
        if (schema.default !== undefined) {
          handleParentChange(schema.default, path);
        } else {
          if (schema.type === SCHEMA_KEYWORDS.BOOLEAN) {
            handleParentChange(false, path);
          }
        }
      }
    }

    const {
      $ref,
      items,
      properties
    } = schema;
    let newNestedSchema = null;

    if (items) {
      if (items.$ref) {
        newNestedSchema = _.cloneDeep(processRef(items.$ref));
      } else if (items.properties) {
        newNestedSchema = _.cloneDeep(items);
      }
    } else {
      if ($ref) {
        newNestedSchema = _.cloneDeep(processRef($ref));
      }

      if (properties) {
        if (!$ref) {
          newNestedSchema = _.cloneDeep(schema);
        }

        addProperties(newNestedSchema, {
          properties: schema.properties,
          required: schema.required ? schema.required : []
        });
      }
    }

    setNestedSchema(newNestedSchema);
    initializeData();
  }, [schema]);

  const handleArrayElementRemoval = index => () => {
    const newVal = [...value];
    newVal.splice(index, 1);
    handleParentChange(newVal, path);
  };

  function renderNestedSchema(pathKey, itemValue, index) {
    return React.createElement(SchemaForm, {
      root: root,
      key: JSON.stringify(nestedSchema),
      path: pathKey,
      schema: nestedSchema,
      data: itemValue,
      errors: errors,
      wrapper: wrapper,
      config: config,
      parentChange: (subVal, key) => {
        if (index !== null) {
          const copy = [...value];
          copy[index] = subVal;
          handleParentChange(copy, key);
        } else {
          handleParentChange(subVal, key);
        }
      }
    });
  }

  function renderPrimitiveArrayItem(itemValue, itemProperty, index) {
    const registryKey = itemProperty.registryKey || (itemProperty.enum || itemProperty.options ? SCHEMA_KEYWORDS.ENUM : itemProperty.contentEncoding || itemProperty.contentMediaType ? SCHEMA_KEYWORDS.FILE : itemProperty.type);
    const pathKey = `${path}[${index}]`;
    let arrayElementErrors = errors.filter(err => err.dataPath === pathKey);

    if (arrayElementErrors && arrayElementErrors.length === 0) {
      arrayElementErrors = false;
    }

    return registry.getComponent({ ...itemProperty,
      path: pathKey,
      registryKey,
      error: arrayElementErrors,
      type: registryKey
    }, itemValue, changedItemValue => {
      const copy = [...value];
      copy[index] = changedItemValue;
      handleParentChange(copy, path);
    }, null);
  }

  function renderArrayOfEnums(itemValue, itemProperty) {
    const key = path.substr(path.lastIndexOf('.') + 1);
    const isRequired = parentSchema.required && parentSchema.required.indexOf(key) > -1;
    return registry.getComponent({
      enum: itemProperty.enum,
      path,
      registryKey: SCHEMA_KEYWORDS.MULTIPLE_ENUM,
      error,
      isRequired,
      title: schema.title,
      type: SCHEMA_KEYWORDS.ENUM
    }, itemValue, changedItemValue => handleParentChange(changedItemValue, path), null);
  }

  function renderArray(itemValue) {
    return React.createElement(Fragment, null, itemValue && itemValue.map((item, index) => React.createElement(Fragment, {
      key: `${path}-${itemValue.length}-${index}`
    }, renderFormElement(item, index), registry.getComponent({
      registryKey: SCHEMA_KEYWORDS.REMOVE_BUTTON,
      className: 'ra-remove-button'
    }, 'Remove item', handleArrayElementRemoval(index)))), registry.getComponent({
      registryKey: SCHEMA_KEYWORDS.ADD_BUTTON,
      className: 'ra-add-button'
    }, 'Add item', () => {
      let emptyChild = {};

      if (!nestedSchema && schema.items && schema.items.type) {
        switch (schema.items.type) {
          case SCHEMA_KEYWORDS.INTEGER:
          case SCHEMA_KEYWORDS.NUMBER:
            emptyChild = typeof schema.items.minimum === 'number' ? schema.items.minimum : 0;
            break;

          case SCHEMA_KEYWORDS.BOOLEAN:
            emptyChild = false;
            break;

          default:
            emptyChild = '';
        }
      }

      handleParentChange([...(itemValue || []), emptyChild], path);
    }));
  }

  function getElementFromRegistry(itemValue, children = null, title, type) {
    const registryKey = schema.registryKey || (schema.enum || schema.options ? SCHEMA_KEYWORDS.ENUM : schema.contentEncoding || schema.contentMediaType || schema.instanceof === SCHEMA_KEYWORDS.FILE ? SCHEMA_KEYWORDS.FILE : schema.type);
    const key = path.substr(path.lastIndexOf('.') + 1);
    const isRequired = parentSchema.required && parentSchema.required.indexOf(key) > -1;
    return registry.getComponent({ ...schema,
      path,
      registryKey,
      error,
      isRequired,
      title: title || schema.title,
      type: type || schema.type,
      contentMediaType: schema.instanceof === SCHEMA_KEYWORDS.FILE ? schema.properties.content.contentMediaType : schema.contentMediaType
    }, itemValue, changedItemValue => handleParentChange(changedItemValue, path), children);
  }

  function renderFormElement(itemValue, index = null) {
    const typeObjectArrayItem = !!nestedSchema && schema.type === SCHEMA_KEYWORDS.ARRAY && index !== null;
    const typeObjectOrObjectArrayItem = !!nestedSchema && schema.type !== SCHEMA_KEYWORDS.ARRAY || typeObjectArrayItem;
    const typePrimitiveArrayItem = !nestedSchema && schema.type === SCHEMA_KEYWORDS.ARRAY && index !== null && !!schema.items && !!schema.items.type;
    const typeArray = schema.type === SCHEMA_KEYWORDS.ARRAY && index === null;
    const typeArrayOfEnums = schema.type === SCHEMA_KEYWORDS.ARRAY && index === null && schema.items && schema.items.type === SCHEMA_KEYWORDS.STRING && schema.items.enum !== undefined;

    if (typeObjectOrObjectArrayItem) {
      const pathKey = index === null ? path : `${path}[${index}]`;
      return getElementFromRegistry(itemValue, renderNestedSchema(pathKey, itemValue, index), nestedSchema.title, typeObjectArrayItem ? nestedSchema.type : schema.type);
    } else if (typePrimitiveArrayItem) {
      return renderPrimitiveArrayItem(itemValue, schema.items, index);
    } else if (typeArrayOfEnums) {
      return renderArrayOfEnums(itemValue, schema.items);
    } else if (typeArray) {
      const arrayItems = renderArray(itemValue);
      return getElementFromRegistry(itemValue, arrayItems);
    } else {
      return getElementFromRegistry(itemValue);
    }
  }

  return renderFormElement(value);
}

var $id = "https://github.com/ascentcore/react-schema-form/tree/master/src/custom-meta-schema.json#";
var $schema = "https://github.com/ascentcore/react-schema-form/tree/master/src/custom-meta-schema.json#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	contentEncodings: {
		"enum": [
			"base64"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	},
	instanceofTypes: {
		"enum": [
			"file"
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	items: {
		oneOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		oneOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	"instanceof": {
		oneOf: [
			{
				$ref: "#/definitions/instanceofTypes"
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		oneOf: [
			{
				$ref: "#/definitions/contentEncodings"
			}
		]
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	}
};
var CustomMetaSchema = {
	$id: $id,
	$schema: $schema,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

const CLASSES = {
  file: ['filename', 'content']
};
class UISchema {
  constructor(jsonSchema) {
    this.schema = { ...jsonSchema
    };
    this.keys = Object.keys(this.schema.properties || {});
    this.ajv = new Ajv({
      allErrors: true,
      meta: CustomMetaSchema
    });
    this.ajv.addKeyword('instanceof', {
      type: "object",
      compile: function (schema, parentSchema) {
        //@ts-ignore
        const objectProperties = CLASSES[schema];

        if (parentSchema.type !== "object") {
          throw new Error(`schema is invalid: instanceof attribute should be present on schema of type object`);
        }

        if (!objectProperties.every(function (property) {
          return Object.prototype.hasOwnProperty.call(parentSchema.properties || {}, property);
        })) {
          throw new Error(`schema is invalid: object instanceof ${schema} is missing one of the fields: ${objectProperties}`);
        }

        return function () {
          return true;
        };
      }
    });
    this.validator = this.ajv.compile({ ...this.schema,
      $schema: 'https://github.com/ascentcore/react-schema-form/tree/master/src/custom-meta-schema.json#'
    });
  }

  validate(data) {
    return this.validator(data);
  }

}

function TextElement({
  value,
  onChange
}) {
  const handleChange = event => {
    onChange(event.target.value);
  };

  return React.createElement("input", {
    type: 'text',
    value: value || "",
    onChange: handleChange
  });
}

const CONTAINER_STYLE = {
  position: 'relative'
};
const FILE_INPUT_STYLE = {
  position: 'absolute',
  opacity: '0',
  width: '100%'
};
function FileElement({
  property,
  value,
  onChange
}) {
  const handleChange = event => {
    const inputElement = event.target;

    if (inputElement.files && inputElement.files.length) {
      const reader = new FileReader();
      reader.addEventListener('load', function () {
        if (reader.result) {
          let fileContent = typeof reader.result === 'string' ? reader.result : Buffer.from(reader.result).toString();
          fileContent = fileContent.split(';base64,')[1];

          if (property.instanceof === 'file') {
            onChange({
              filename: inputElement.files[0].name,
              content: fileContent
            });
          } else {
            onChange(fileContent);
          }
        }
      });
      reader.readAsDataURL(inputElement.files[0]);
    }
  };

  return React.createElement("span", {
    style: CONTAINER_STYLE
  }, React.createElement("input", Object.assign({
    type: 'file',
    onChange: handleChange,
    style: FILE_INPUT_STYLE
  }, property.contentMediaType ? {
    accept: property.contentMediaType
  } : {})), React.createElement("button", null, "Choose file"), React.createElement("span", null, value ? ' File uploaded' : ' No file chosen'));
}

function isNumeric(value) {
  return !isNaN(parseInt(value)) || !isNaN(parseFloat(value));
}

function NumericElement({
  property,
  value,
  onChange
}) {
  const handleChange = event => {
    const {
      type
    } = property;
    const {
      value
    } = event.target;

    if (isNumeric(value)) {
      if (type === 'integer') {
        onChange(parseInt(value));
      } else {
        onChange(parseFloat(value));
      }
    } else {
      onChange('');
    }
  };

  return React.createElement("input", {
    type: 'number',
    value: value !== undefined ? value : '',
    onChange: handleChange
  });
}

function SelectElement({
  property,
  value,
  onChange
}) {
  const [options, setOptions] = useState([]);
  let [labelKey, valueKey] = [property.labelKey || 'labelKey', property.valueKey || 'valueKey'];
  useEffect(() => {
    let opts = property.options;

    if (property.enum) {
      opts = property.enum.map(item => ({
        labelKey: item,
        valueKey: item
      }));
    } else {
      labelKey = property.labelKey || labelKey;
      valueKey = property.valueKey || valueKey;
    }

    opts && setOptions(opts);
  }, [property]);

  const handleChange = event => {
    onChange(event.target.value);
  };

  return React.createElement("select", {
    onChange: handleChange,
    value: value !== undefined ? value : ''
  }, !value && React.createElement("option", {
    value: '',
    disabled: true
  }, "Select your option"), options.map(opt => React.createElement("option", {
    key: opt[labelKey],
    value: opt[valueKey]
  }, opt[labelKey])));
}

function RadioElement({
  property,
  value,
  onChange
}) {
  const [options, setOptions] = useState([]);
  let [labelKey, valueKey] = [property.labelKey || 'labelKey', property.valueKey || 'valueKey'];
  useEffect(() => {
    let opts = property.options;

    if (property.enum) {
      opts = property.enum.map(item => ({
        labelKey: item,
        valueKey: item
      }));
    } else {
      labelKey = property.labelKey || labelKey;
      valueKey = property.valueKey || valueKey;
    }

    opts && setOptions(opts);
  }, [property]);

  const handleChange = event => {
    onChange(event.target.value);
  };

  return React.createElement("span", null, options.map(opt => React.createElement("div", {
    className: 'radio',
    key: opt[labelKey]
  }, React.createElement("label", null, React.createElement("input", {
    type: 'radio',
    value: opt[valueKey],
    checked: value === opt[valueKey],
    onChange: handleChange
  }), ` ${opt[valueKey]}`))));
}

function CheckboxElement({
  value,
  onChange
}) {
  const handleChange = event => {
    onChange(event.target.checked);
  };

  return React.createElement("input", {
    type: 'checkbox',
    value: `${value || false}`,
    onChange: handleChange,
    checked: value || false
  });
}

function ButtonElement({
  property,
  value,
  onChange,
  children
}) {
  return React.createElement("button", {
    className: property.className,
    onClick: onChange
  }, value ? value : children);
}

function MultipleSelectElement({
  property,
  value,
  onChange
}) {
  const [options, setOptions] = useState([]);
  let [labelKey, valueKey] = [property.labelKey || 'labelKey', property.valueKey || 'valueKey'];
  useEffect(() => {
    let opts = property.options;

    if (property.enum) {
      opts = property.enum.map(item => ({
        labelKey: item,
        valueKey: item
      }));
    } else {
      labelKey = property.labelKey || labelKey;
      valueKey = property.valueKey || valueKey;
    }

    opts && setOptions(opts);
  }, [property]);

  const handleChange = event => {
    const options = event.target.options;
    const value = [];

    for (let i = 0, l = options.length; i < l; i++) {
      if (options[i].selected) {
        value.push(options[i].value);
      }
    }

    onChange(value);
  };

  return React.createElement("select", {
    multiple: true,
    onChange: handleChange,
    value: value || []
  }, React.createElement("option", {
    value: '',
    disabled: true
  }, "Select your options"), options.map(opt => React.createElement("option", {
    key: opt[labelKey],
    value: opt[valueKey]
  }, opt[labelKey])));
}

const InputElements = {
  TextElement,
  FileElement,
  NumericElement,
  SelectElement,
  CheckboxElement,
  ButtonElement,
  RadioElement,
  MultipleSelectElement
};

function ElementContainer({
  children
}) {
  return React.createElement(Fragment, null, children);
}

function ElementWrapper({
  children,
  property
}) {
  const {
    type
  } = property;
  const wrapperClass = `${property.type !== 'object' && property.type !== 'array' ? 'ra-elem-wrapper ' : 'ra-elem-instance'}
        ra-elem-${property.type}     
        ${property.error ? 'ra-error' : ''}`;

  const labelComponent = () => {
    if (type !== 'array' && type !== 'object') {
      return React.createElement("label", {
        className: 'ra-form-label'
      }, property.title, property.isRequired && '*');
    } else {
      return React.createElement("div", {
        className: 'ra-form-title'
      }, property.title, property.isRequired && '*');
    }
  };

  return React.createElement("span", {
    className: wrapperClass
  }, labelComponent(), children, property.error && React.createElement("span", {
    className: 'ra-elem-error-text'
  }, typeof property.error !== 'boolean' && property.error[0].message));
}

const transformStringEntries = registryEntries => {
  Object.entries(registryEntries).forEach(registryEntry => {
    if (typeof registryEntry[1].component === 'string') {
      if (InputElements[registryEntry[1].component]) {
        registryEntry[1].component = InputElements[registryEntry[1].component];
      } else {
        registryEntry[1].component = ElementContainer;
      }
    }
  });
};

class ComponentRegistry {
  constructor(customRegistry = {}, wrapper = ElementWrapper, exceptions = {
    paths: {},
    keys: {}
  }) {
    this._registry = {
      enum: {
        component: InputElements['SelectElement'],
        wrapper: wrapper
      },
      multipleEnum: {
        component: InputElements['MultipleSelectElement'],
        wrapper: wrapper
      },
      boolean: {
        component: InputElements['CheckboxElement'],
        wrapper: wrapper
      },
      number: {
        component: InputElements['NumericElement'],
        wrapper: wrapper
      },
      integer: {
        component: InputElements['NumericElement'],
        wrapper: wrapper
      },
      string: {
        component: InputElements['TextElement'],
        wrapper: wrapper
      },
      file: {
        component: InputElements['FileElement'],
        wrapper: wrapper
      },
      button: {
        component: InputElements['ButtonElement'],
        wrapper: ElementContainer
      },
      addButton: {
        component: InputElements['ButtonElement'],
        wrapper: ElementContainer
      },
      removeButton: {
        component: InputElements['ButtonElement'],
        wrapper: ElementContainer
      }
    };
    Object.keys(customRegistry).forEach(key => {
      this._registry[`${key}`] = customRegistry[key];
    });
    this._wrapper = wrapper;
    this._exceptions = Object.assign({
      paths: {},
      keys: {}
    }, exceptions);
    transformStringEntries(this._registry);
    transformStringEntries(this._exceptions.paths);
    transformStringEntries(this._exceptions.keys);
  }

  getComponent(property, itemValue, handleChange, children = null) {
    const props = {
      property,
      value: itemValue,
      onChange: handleChange,
      children: children
    };
    const pathException = property.path && this._exceptions.paths[property.path];

    const keyException = property.path && this._exceptions.keys[property.path.substr(property.path.lastIndexOf('.') + 1)];

    const Component = pathException && pathException.component || keyException && keyException.component || this._registry[property.registryKey] && this._registry[property.registryKey].component || ElementContainer;
    const Wrapper = pathException && pathException.wrapper || keyException && keyException.wrapper || this._registry[property.registryKey] && this._registry[property.registryKey].wrapper || this._wrapper;
    return React.createElement(Wrapper, Object.assign({}, props), React.createElement(Component, Object.assign({}, props)));
  }

}

const formatters = {
  'required': error => {
    return 'Field is required';
  },
  'minLength': error => {
    const params = error.params;
    return `Field must not exceed ${params.limit} characters`;
  },
  'maxLength': error => {
    const params = error.params;
    return `Field must bet at least ${params.limit} characters`;
  },
  'pattern': error => {
    const params = error.params;
    return `Field does not match pattern (${params.pattern})`;
  },
  'minimum': error => {
    const params = error.params;
    return `Value should be at least ${params.limit}`;
  },
  'maximum': error => {
    const params = error.params;
    return `Value should be at most ${params.limit}`;
  },
  'exclusiveMinimum': error => {
    const params = error.params;
    return `Value should be greater than ${params.limit}`;
  },
  'exclusiveMaximum': error => {
    const params = error.params;
    return `Value should be lower than ${params.limit}`;
  },
  'minItems': error => {
    const params = error.params;
    return `Should not have fewer than ${params.limit} items`;
  },
  'uniqueItems': error => {
    return 'Should not contain duplicate items';
  }
};
function formatErrors(errors, customFn) {
  if (errors) {
    errors.forEach(error => {
      if (customFn) {
        customFn(error);
      } else {
        const {
          keyword
        } = error;
        const formatter = formatters[keyword];

        if (formatter) {
          error.message = formatter(error);
        }
      }
    });
  }

  return errors;
}

const _$1 = require('lodash');

const SchemaForm = ({
  schema,
  root: _root = schema,
  wrapper: _wrapper = ElementWrapper,
  parentChange: _parentChange = null,
  className,
  data: _data = {},
  config: _config = null,
  onSubmit: _onSubmit = () => {},
  errorFormatter: _errorFormatter = null,
  path: _path = '',
  errors: parentErrors = null
}) => {
  if (!schema) {
    throw new Error('schema must be provided to the SchemaForm component');
  }

  const [currentSchema, setCurrentSchema] = useState(null);
  const [obj, setObj] = useState(Object.assign({}, {
    data: _data,
    childPath: null
  }));
  const [keys, setKeys] = useState(Object.keys(schema.properties || {}));
  const [instance] = useState(() => _parentChange ? null : new UISchema(schema));
  const [registry] = useState(() => new ComponentRegistry(_config && _config.registry ? _config.registry : {}, _wrapper, _config && _config.exceptions ? _config.exceptions : {
    paths: {},
    keys: {}
  }));
  const [errors, setErrors] = useState([]);
  const [conditionals] = useState(() => {
    const data = getConditionals(schema);
    return {
      data,
      lastEvaluations: ''
    };
  });

  const removeObjPath = (path, obj) => {
    const prop = path[0];

    if (path.length > 1) {
      prop && removeObjPath(path.slice(1), obj ? obj[prop] : null);

      if (prop && obj && obj[prop] && Object.keys(obj[prop]).length === 0) {
        delete obj[prop];
      }
    } else {
      if (obj && prop && obj[prop] != undefined) {
        delete obj[prop];
      }
    }
  };

  const removeProperties = (currentSchema, baseSchema, nestedPath) => {
    if (isObject(currentSchema) && isObject(baseSchema)) {
      if (currentSchema.$ref !== undefined) {
        const def = currentSchema.$ref.substr(currentSchema.$ref.lastIndexOf('/') + 1);
        _root && _root.definitions[def] && addProperties(currentSchema, _root.definitions[def]);
      }

      for (const key in baseSchema) {
        if (!currentSchema[key]) {
          handleParentChange(key)(undefined, `${nestedPath}.${key}`, `${nestedPath}.${key}`);
        } else {
          removeProperties(currentSchema[key], baseSchema[key], key !== SCHEMA_KEYWORDS.PROPERTIES ? `${nestedPath}.${key}` : nestedPath);
        }
      }
    }
  };

  const removeData = (schema, currentData) => {
    if (isObject(schema) && isObject(currentData)) {
      if (schema.$ref !== undefined) {
        const def = schema.$ref.substr(schema.$ref.lastIndexOf('/') + 1);
        _root && _root.definitions[def] && addProperties(schema, _root.definitions[def]);
      }

      for (const key in currentData) {
        if (schema.properties && schema.properties[key] === undefined) {
          delete currentData[key];
        } else {
          removeData(schema.properties && schema.properties[key], currentData[key]);

          if (isObject(currentData[key]) && Object.keys(currentData[key]).length === 0) {
            delete currentData[key];
          }
        }
      }
    }
  };

  const checkConditionals = actualSchema => {
    if (conditionals.data.length) {
      let lastEvaluation = '',
          currentEvaluation;

      const newSchema = _$1.cloneDeep(schema);

      let newData = _$1.cloneDeep(obj.data);

      let lastEvaluations = '';

      while (lastEvaluation !== currentEvaluation) {
        currentEvaluation = lastEvaluation;
        lastEvaluation = '';
        conditionals.data.forEach(conditional => {
          try {
            const evalCondition = eval(conditional.compiled)(newData);

            if (evalCondition) {
              addProperties(newSchema, conditional.then);
              newData = _$1.cloneDeep(obj.data);
              removeData(newSchema, newData);
              lastEvaluation += '1';
            } else {
              addProperties(newSchema, conditional.else || {});
              newData = _$1.cloneDeep(obj.data);
              removeData(newSchema, newData);
              lastEvaluation += '2';
            }
          } catch (err) {
            // property does not exist on data;
            lastEvaluation += '0';
          }
        });
        lastEvaluations += lastEvaluation;
      }

      if (lastEvaluations !== conditionals.lastEvaluations) {
        removeProperties(newSchema, actualSchema, '');
        setCurrentSchema(newSchema);
        setKeys(Object.keys(newSchema.properties || {}));
        conditionals.lastEvaluations = lastEvaluations;
      }
    }
  };

  const handleParentChange = key => (value, childPath, nestedPath) => {
    if (nestedPath) {
      setObj(prevObj => {
        const newObj = Object.assign({}, { ...prevObj
        });
        removeObjPath(nestedPath.substr(1).split('.'), newObj.data);
        return newObj;
      });
    } else {
      setObj(prevObj => {
        const newValue = Object.assign({
          childPath
        }, {
          data: { ...prevObj.data,
            [key]: value
          }
        });

        if (value === undefined || value === '' || value && value.constructor === Array && value.length === 0) {
          delete newValue.data[key];
        }

        return newValue;
      });
    }
  };

  const handleSubmit = () => {
    const result = instance.validate(obj.data);
    const errors = result || !instance.validator.errors ? [] : instance.validator.errors;
    errors.forEach((err, index, object) => {
      if (err.keyword === SCHEMA_KEYWORDS.IF) {
        object.splice(index, 1);
      } else if (err.params && err.params.missingProperty) {
        err.dataPath += `.${err.params.missingProperty}`;
      }
    });
    const formattedErrors = formatErrors(errors, _errorFormatter);
    setErrors(formattedErrors);

    _onSubmit(obj.data, formattedErrors);
  };

  const getErrors = path => {
    const errArr = [...errors, ...(parentErrors || [])];
    let result = errArr.filter(err => err.dataPath === path);

    if (result && result.length === 0) {
      result = false;
    }

    return result;
  };

  useEffect(() => {
    setCurrentSchema(_$1.cloneDeep(schema));
    setKeys(Object.keys(schema.properties || {}));
  }, [schema]);
  useEffect(() => {
    checkConditionals(currentSchema || schema);

    if (_parentChange && obj.childPath) {
      _parentChange(obj.data, obj.childPath);
    } else {
      setErrors(errors.filter(item => item.dataPath !== obj.childPath));
    }
  }, [obj]);
  return React.createElement("span", {
    className: `${className} ra-schema-form`
  }, currentSchema && keys.map(key => {
    const childPath = `${_path}.${key}`;
    const prop = currentSchema.properties[key];
    return React.createElement(FormElement, {
      root: _root,
      key: key,
      config: _config,
      wrapper: _wrapper,
      error: getErrors(childPath),
      errors: parentErrors || errors,
      value: obj.data ? obj.data[key] : undefined,
      schema: prop,
      path: childPath,
      parentSchema: currentSchema,
      handleParentChange: handleParentChange(key),
      registry: registry
    });
  }), !_parentChange && registry.getComponent({
    registryKey: SCHEMA_KEYWORDS.BUTTON,
    className: 'ra-submit-button'
  }, 'Submit', handleSubmit));
};

export { SchemaForm };
//# sourceMappingURL=index.modern.js.map
