function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var Ajv = _interopDefault(require('ajv'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var SCHEMA_KEYWORDS = {
  PROPERTIES: 'properties',
  REQUIRED: 'required',
  CONST: 'const',
  IF: 'if',
  BOOLEAN: 'boolean',
  NUMBER: 'number',
  INTEGER: 'integer',
  ARRAY: 'array',
  OBJECT: 'object',
  STRING: 'string',
  MULTIPLE_ENUM: 'multipleEnum',
  ENUM: 'enum',
  FILE: 'file',
  BUTTON: 'button',
  REMOVE_BUTTON: 'removeButton',
  ADD_BUTTON: 'addButton'
};

var isObject = function isObject(item) {
  return item && typeof item === SCHEMA_KEYWORDS.OBJECT && !Array.isArray(item);
}; //merges the current object at all nesting levels with a new one
//the method does not return a new object; the current one is being altered

var addProperties = function addProperties(currentObject, newProperties) {
  if (isObject(currentObject) && isObject(newProperties)) {
    for (var key in newProperties) {
      if (isObject(newProperties[key])) {
        if (!currentObject[key]) {
          var _Object$assign;

          Object.assign(currentObject, (_Object$assign = {}, _Object$assign[key] = {}, _Object$assign));
        }

        addProperties(currentObject[key], newProperties[key]);
      } else {
        if (key === SCHEMA_KEYWORDS.REQUIRED && Array.isArray(newProperties[key]) && Array.isArray(currentObject[key])) {
          var _currentObject$key;

          //@ts-ignore
          currentObject[key] = [].concat(new Set((_currentObject$key = currentObject[key]).concat.apply(_currentObject$key, newProperties[key])));
        } else {
          var _Object$assign2;

          Object.assign(currentObject, (_Object$assign2 = {}, _Object$assign2[key] = newProperties[key], _Object$assign2));
        }
      }
    }
  }
}; //gets all conditionals specified at root level of a schema;
//conditionals that are both specified with simple ifs, or as a list with allOf, anyOf, oneOf

var getConditionals = function getConditionals(schema) {
  var ifEntries = [];
  var simpleConditional = getSimpleConditional(schema);

  if (simpleConditional) {
    ifEntries.push(simpleConditional);
  }

  ifEntries = ifEntries.concat(getMultipleConditionals(schema));
  var compiledIfEntries = ifEntries.map(function (ifEntry) {
    return getCompiledConditional(ifEntry);
  });
  var compiledDependencies = [];

  if (schema.dependencies) {
    compiledDependencies = getCompiledDependencies(schema.dependencies);
  }

  return compiledIfEntries.concat(compiledDependencies);
}; //given a schema, the function will return a list with all the paths of the schema and the value of the leaf node
//keywords such as properties and const are not included
//usage: extract all the conditions specified inside an if statement

var getPropertyPathsIfStatement = function getPropertyPathsIfStatement(schema, path) {
  if (path === void 0) {
    path = '';
  }

  if (isObject(schema)) {
    return Array.prototype.concat.apply([], Object.keys(schema).map(function (key) {
      return getPropertyPathsIfStatement(schema[key], key === SCHEMA_KEYWORDS.PROPERTIES || key === SCHEMA_KEYWORDS.CONST ? path : path + '.' + key);
    }));
  } else {
    return [{
      '0': path,
      '1': schema
    }];
  }
}; //extract conditional from a simple if statement


var getSimpleConditional = function getSimpleConditional(schema) {
  if (schema["if"] && schema["if"].properties) {
    return {
      "if": getPropertyPathsIfStatement(schema["if"]),
      then: schema.then,
      "else": schema["else"]
    };
  } else {
    return null;
  }
}; //extract conditionals from array


var extractConditionalFromArray = function extractConditionalFromArray(conditionalSet) {
  return conditionalSet.filter(function (entry) {
    return entry["if"] !== undefined;
  }).map(function (conditional) {
    return {
      "if": getPropertyPathsIfStatement(conditional["if"]),
      then: conditional.then,
      "else": conditional["else"]
    };
  });
}; //extract conditionals from allOf, anyOf, oneOf statements


var getMultipleConditionals = function getMultipleConditionals(schema) {
  var multipleConditionals = [];

  if (schema.allOf) {
    multipleConditionals = multipleConditionals.concat(extractConditionalFromArray(schema.allOf));
  }

  if (schema.anyOf) {
    multipleConditionals = multipleConditionals.concat(extractConditionalFromArray(schema.anyOf));
  }

  if (schema.oneOf) {
    multipleConditionals = multipleConditionals.concat(extractConditionalFromArray(schema.oneOf));
  }

  return multipleConditionals;
}; //constructs string function which will be compiled when needed;
//rewrites the condition under an if statement as a function


var getCompiledConditional = function getCompiledConditional(ifEntry) {
  var compiled = "data => { return (" + ifEntry["if"].reduce(function (memo, item) {
    return memo.concat(['data' + item[0] + '==' + (typeof item[1] === SCHEMA_KEYWORDS.STRING ? "'" + item[1] + "'" : item[1])]);
  }, []).join(' && ') + ") || (" + ifEntry["if"].reduce(function (memo, item) {
    return memo.concat(['data' + item[0] + '==' + 'undefined']);
  }, []).join(' && ') + ") }";
  return _extends({
    compiled: compiled
  }, ifEntry.then ? {
    then: ifEntry.then
  } : {}, ifEntry["else"] ? {
    "else": ifEntry["else"]
  } : {});
};

var getCompiledDependencies = function getCompiledDependencies(dependencies) {
  return Object.entries(dependencies).map(function (dependency) {
    var compiled = "data => { return (data." + dependency[0] + " !== undefined) }";
    return _extends({
      compiled: compiled
    }, Array.isArray(dependency[1]) ? {
      then: {
        required: dependency[1]
      }
    } : {
      then: dependency[1]
    });
  });
};

var _ = require('lodash');

function FormElement(_ref) {
  var root = _ref.root,
      parentSchema = _ref.parentSchema,
      schema = _ref.schema,
      path = _ref.path,
      value = _ref.value,
      errors = _ref.errors,
      error = _ref.error,
      handleParentChange = _ref.handleParentChange,
      registry = _ref.registry,
      wrapper = _ref.wrapper,
      config = _ref.config;

  var _useState = React.useState(null),
      nestedSchema = _useState[0],
      setNestedSchema = _useState[1];

  React.useEffect(function () {
    function processRef($ref) {
      var def = $ref.substr($ref.lastIndexOf('/') + 1);
      return root.definitions[def];
    }

    function initializeData() {
      if (value === undefined) {
        if (schema["default"] !== undefined) {
          handleParentChange(schema["default"], path);
        } else {
          if (schema.type === SCHEMA_KEYWORDS.BOOLEAN) {
            handleParentChange(false, path);
          }
        }
      }
    }

    var $ref = schema.$ref,
        items = schema.items,
        properties = schema.properties;
    var newNestedSchema = null;

    if (items) {
      if (items.$ref) {
        newNestedSchema = _.cloneDeep(processRef(items.$ref));
      } else if (items.properties) {
        newNestedSchema = _.cloneDeep(items);
      }
    } else {
      if ($ref) {
        newNestedSchema = _.cloneDeep(processRef($ref));
      }

      if (properties) {
        if (!$ref) {
          newNestedSchema = _.cloneDeep(schema);
        }

        addProperties(newNestedSchema, {
          properties: schema.properties,
          required: schema.required ? schema.required : []
        });
      }
    }

    setNestedSchema(newNestedSchema);
    initializeData();
  }, [schema]);

  var handleArrayElementRemoval = function handleArrayElementRemoval(index) {
    return function () {
      var newVal = [].concat(value);
      newVal.splice(index, 1);
      handleParentChange(newVal, path);
    };
  };

  function renderNestedSchema(pathKey, itemValue, index) {
    return React__default.createElement(SchemaForm, {
      root: root,
      key: JSON.stringify(nestedSchema),
      path: pathKey,
      schema: nestedSchema,
      data: itemValue,
      errors: errors,
      wrapper: wrapper,
      config: config,
      parentChange: function parentChange(subVal, key) {
        if (index !== null) {
          var copy = [].concat(value);
          copy[index] = subVal;
          handleParentChange(copy, key);
        } else {
          handleParentChange(subVal, key);
        }
      }
    });
  }

  function renderPrimitiveArrayItem(itemValue, itemProperty, index) {
    var registryKey = itemProperty.registryKey || (itemProperty["enum"] || itemProperty.options ? SCHEMA_KEYWORDS.ENUM : itemProperty.contentEncoding || itemProperty.contentMediaType ? SCHEMA_KEYWORDS.FILE : itemProperty.type);
    var pathKey = path + "[" + index + "]";
    var arrayElementErrors = errors.filter(function (err) {
      return err.dataPath === pathKey;
    });

    if (arrayElementErrors && arrayElementErrors.length === 0) {
      arrayElementErrors = false;
    }

    return registry.getComponent(_extends({}, itemProperty, {
      path: pathKey,
      registryKey: registryKey,
      error: arrayElementErrors,
      type: registryKey
    }), itemValue, function (changedItemValue) {
      var copy = [].concat(value);
      copy[index] = changedItemValue;
      handleParentChange(copy, path);
    }, null);
  }

  function renderArrayOfEnums(itemValue, itemProperty) {
    var key = path.substr(path.lastIndexOf('.') + 1);
    var isRequired = parentSchema.required && parentSchema.required.indexOf(key) > -1;
    return registry.getComponent({
      "enum": itemProperty["enum"],
      path: path,
      registryKey: SCHEMA_KEYWORDS.MULTIPLE_ENUM,
      error: error,
      isRequired: isRequired,
      title: schema.title,
      type: SCHEMA_KEYWORDS.ENUM
    }, itemValue, function (changedItemValue) {
      return handleParentChange(changedItemValue, path);
    }, null);
  }

  function renderArray(itemValue) {
    return React__default.createElement(React.Fragment, null, itemValue && itemValue.map(function (item, index) {
      return React__default.createElement(React.Fragment, {
        key: path + "-" + itemValue.length + "-" + index
      }, renderFormElement(item, index), registry.getComponent({
        registryKey: SCHEMA_KEYWORDS.REMOVE_BUTTON,
        className: 'ra-remove-button'
      }, 'Remove item', handleArrayElementRemoval(index)));
    }), registry.getComponent({
      registryKey: SCHEMA_KEYWORDS.ADD_BUTTON,
      className: 'ra-add-button'
    }, 'Add item', function () {
      var emptyChild = {};

      if (!nestedSchema && schema.items && schema.items.type) {
        switch (schema.items.type) {
          case SCHEMA_KEYWORDS.INTEGER:
          case SCHEMA_KEYWORDS.NUMBER:
            emptyChild = typeof schema.items.minimum === 'number' ? schema.items.minimum : 0;
            break;

          case SCHEMA_KEYWORDS.BOOLEAN:
            emptyChild = false;
            break;

          default:
            emptyChild = '';
        }
      }

      handleParentChange([].concat(itemValue || [], [emptyChild]), path);
    }));
  }

  function getElementFromRegistry(itemValue, children, title, type) {
    if (children === void 0) {
      children = null;
    }

    var registryKey = schema.registryKey || (schema["enum"] || schema.options ? SCHEMA_KEYWORDS.ENUM : schema.contentEncoding || schema.contentMediaType || schema["instanceof"] === SCHEMA_KEYWORDS.FILE ? SCHEMA_KEYWORDS.FILE : schema.type);
    var key = path.substr(path.lastIndexOf('.') + 1);
    var isRequired = parentSchema.required && parentSchema.required.indexOf(key) > -1;
    return registry.getComponent(_extends({}, schema, {
      path: path,
      registryKey: registryKey,
      error: error,
      isRequired: isRequired,
      title: title || schema.title,
      type: type || schema.type,
      contentMediaType: schema["instanceof"] === SCHEMA_KEYWORDS.FILE ? schema.properties.content.contentMediaType : schema.contentMediaType
    }), itemValue, function (changedItemValue) {
      return handleParentChange(changedItemValue, path);
    }, children);
  }

  function renderFormElement(itemValue, index) {
    if (index === void 0) {
      index = null;
    }

    var typeObjectArrayItem = !!nestedSchema && schema.type === SCHEMA_KEYWORDS.ARRAY && index !== null;
    var typeObjectOrObjectArrayItem = !!nestedSchema && schema.type !== SCHEMA_KEYWORDS.ARRAY || typeObjectArrayItem;
    var typePrimitiveArrayItem = !nestedSchema && schema.type === SCHEMA_KEYWORDS.ARRAY && index !== null && !!schema.items && !!schema.items.type;
    var typeArray = schema.type === SCHEMA_KEYWORDS.ARRAY && index === null;
    var typeArrayOfEnums = schema.type === SCHEMA_KEYWORDS.ARRAY && index === null && schema.items && schema.items.type === SCHEMA_KEYWORDS.STRING && schema.items["enum"] !== undefined;

    if (typeObjectOrObjectArrayItem) {
      var pathKey = index === null ? path : path + "[" + index + "]";
      return getElementFromRegistry(itemValue, renderNestedSchema(pathKey, itemValue, index), nestedSchema.title, typeObjectArrayItem ? nestedSchema.type : schema.type);
    } else if (typePrimitiveArrayItem) {
      return renderPrimitiveArrayItem(itemValue, schema.items, index);
    } else if (typeArrayOfEnums) {
      return renderArrayOfEnums(itemValue, schema.items);
    } else if (typeArray) {
      var arrayItems = renderArray(itemValue);
      return getElementFromRegistry(itemValue, arrayItems);
    } else {
      return getElementFromRegistry(itemValue);
    }
  }

  return renderFormElement(value);
}

var $id = "https://github.com/ascentcore/react-schema-form/tree/master/src/custom-meta-schema.json#";
var $schema = "https://github.com/ascentcore/react-schema-form/tree/master/src/custom-meta-schema.json#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	contentEncodings: {
		"enum": [
			"base64"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	},
	instanceofTypes: {
		"enum": [
			"file"
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	items: {
		oneOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		oneOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	"instanceof": {
		oneOf: [
			{
				$ref: "#/definitions/instanceofTypes"
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		oneOf: [
			{
				$ref: "#/definitions/contentEncodings"
			}
		]
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	}
};
var CustomMetaSchema = {
	$id: $id,
	$schema: $schema,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

var CLASSES = {
  file: ['filename', 'content']
};

var UISchema = /*#__PURE__*/function () {
  function UISchema(jsonSchema) {
    this.schema = _extends({}, jsonSchema);
    this.keys = Object.keys(this.schema.properties || {});
    this.ajv = new Ajv({
      allErrors: true,
      meta: CustomMetaSchema
    });
    this.ajv.addKeyword('instanceof', {
      type: "object",
      compile: function compile(schema, parentSchema) {
        //@ts-ignore
        var objectProperties = CLASSES[schema];

        if (parentSchema.type !== "object") {
          throw new Error("schema is invalid: instanceof attribute should be present on schema of type object");
        }

        if (!objectProperties.every(function (property) {
          return Object.prototype.hasOwnProperty.call(parentSchema.properties || {}, property);
        })) {
          throw new Error("schema is invalid: object instanceof " + schema + " is missing one of the fields: " + objectProperties);
        }

        return function () {
          return true;
        };
      }
    });
    this.validator = this.ajv.compile(_extends({}, this.schema, {
      $schema: 'https://github.com/ascentcore/react-schema-form/tree/master/src/custom-meta-schema.json#'
    }));
  }

  var _proto = UISchema.prototype;

  _proto.validate = function validate(data) {
    return this.validator(data);
  };

  return UISchema;
}();

function TextElement(_ref) {
  var value = _ref.value,
      onChange = _ref.onChange;

  var handleChange = function handleChange(event) {
    onChange(event.target.value);
  };

  return React__default.createElement("input", {
    type: 'text',
    value: value || "",
    onChange: handleChange
  });
}

var CONTAINER_STYLE = {
  position: 'relative'
};
var FILE_INPUT_STYLE = {
  position: 'absolute',
  opacity: '0',
  width: '100%'
};
function FileElement(_ref) {
  var property = _ref.property,
      value = _ref.value,
      onChange = _ref.onChange;

  var handleChange = function handleChange(event) {
    var inputElement = event.target;

    if (inputElement.files && inputElement.files.length) {
      var reader = new FileReader();
      reader.addEventListener('load', function () {
        if (reader.result) {
          var fileContent = typeof reader.result === 'string' ? reader.result : Buffer.from(reader.result).toString();
          fileContent = fileContent.split(';base64,')[1];

          if (property["instanceof"] === 'file') {
            onChange({
              filename: inputElement.files[0].name,
              content: fileContent
            });
          } else {
            onChange(fileContent);
          }
        }
      });
      reader.readAsDataURL(inputElement.files[0]);
    }
  };

  return React__default.createElement("span", {
    style: CONTAINER_STYLE
  }, React__default.createElement("input", Object.assign({
    type: 'file',
    onChange: handleChange,
    style: FILE_INPUT_STYLE
  }, property.contentMediaType ? {
    accept: property.contentMediaType
  } : {})), React__default.createElement("button", null, "Choose file"), React__default.createElement("span", null, value ? ' File uploaded' : ' No file chosen'));
}

function isNumeric(value) {
  return !isNaN(parseInt(value)) || !isNaN(parseFloat(value));
}

function NumericElement(_ref) {
  var property = _ref.property,
      value = _ref.value,
      onChange = _ref.onChange;

  var handleChange = function handleChange(event) {
    var type = property.type;
    var value = event.target.value;

    if (isNumeric(value)) {
      if (type === 'integer') {
        onChange(parseInt(value));
      } else {
        onChange(parseFloat(value));
      }
    } else {
      onChange('');
    }
  };

  return React__default.createElement("input", {
    type: 'number',
    value: value !== undefined ? value : '',
    onChange: handleChange
  });
}

function SelectElement(_ref) {
  var property = _ref.property,
      value = _ref.value,
      onChange = _ref.onChange;

  var _useState = React.useState([]),
      options = _useState[0],
      setOptions = _useState[1];

  var _ref2 = [property.labelKey || 'labelKey', property.valueKey || 'valueKey'],
      labelKey = _ref2[0],
      valueKey = _ref2[1];
  React.useEffect(function () {
    var opts = property.options;

    if (property["enum"]) {
      opts = property["enum"].map(function (item) {
        return {
          labelKey: item,
          valueKey: item
        };
      });
    } else {
      labelKey = property.labelKey || labelKey;
      valueKey = property.valueKey || valueKey;
    }

    opts && setOptions(opts);
  }, [property]);

  var handleChange = function handleChange(event) {
    onChange(event.target.value);
  };

  return React__default.createElement("select", {
    onChange: handleChange,
    value: value !== undefined ? value : ''
  }, !value && React__default.createElement("option", {
    value: '',
    disabled: true
  }, "Select your option"), options.map(function (opt) {
    return React__default.createElement("option", {
      key: opt[labelKey],
      value: opt[valueKey]
    }, opt[labelKey]);
  }));
}

function RadioElement(_ref) {
  var property = _ref.property,
      value = _ref.value,
      onChange = _ref.onChange;

  var _useState = React.useState([]),
      options = _useState[0],
      setOptions = _useState[1];

  var _ref2 = [property.labelKey || 'labelKey', property.valueKey || 'valueKey'],
      labelKey = _ref2[0],
      valueKey = _ref2[1];
  React.useEffect(function () {
    var opts = property.options;

    if (property["enum"]) {
      opts = property["enum"].map(function (item) {
        return {
          labelKey: item,
          valueKey: item
        };
      });
    } else {
      labelKey = property.labelKey || labelKey;
      valueKey = property.valueKey || valueKey;
    }

    opts && setOptions(opts);
  }, [property]);

  var handleChange = function handleChange(event) {
    onChange(event.target.value);
  };

  return React__default.createElement("span", null, options.map(function (opt) {
    return React__default.createElement("div", {
      className: 'radio',
      key: opt[labelKey]
    }, React__default.createElement("label", null, React__default.createElement("input", {
      type: 'radio',
      value: opt[valueKey],
      checked: value === opt[valueKey],
      onChange: handleChange
    }), " " + opt[valueKey]));
  }));
}

function CheckboxElement(_ref) {
  var value = _ref.value,
      onChange = _ref.onChange;

  var handleChange = function handleChange(event) {
    onChange(event.target.checked);
  };

  return React__default.createElement("input", {
    type: 'checkbox',
    value: "" + (value || false),
    onChange: handleChange,
    checked: value || false
  });
}

function ButtonElement(_ref) {
  var property = _ref.property,
      value = _ref.value,
      onChange = _ref.onChange,
      children = _ref.children;
  return React__default.createElement("button", {
    className: property.className,
    onClick: onChange
  }, value ? value : children);
}

function MultipleSelectElement(_ref) {
  var property = _ref.property,
      value = _ref.value,
      onChange = _ref.onChange;

  var _useState = React.useState([]),
      options = _useState[0],
      setOptions = _useState[1];

  var _ref2 = [property.labelKey || 'labelKey', property.valueKey || 'valueKey'],
      labelKey = _ref2[0],
      valueKey = _ref2[1];
  React.useEffect(function () {
    var opts = property.options;

    if (property["enum"]) {
      opts = property["enum"].map(function (item) {
        return {
          labelKey: item,
          valueKey: item
        };
      });
    } else {
      labelKey = property.labelKey || labelKey;
      valueKey = property.valueKey || valueKey;
    }

    opts && setOptions(opts);
  }, [property]);

  var handleChange = function handleChange(event) {
    var options = event.target.options;
    var value = [];

    for (var i = 0, l = options.length; i < l; i++) {
      if (options[i].selected) {
        value.push(options[i].value);
      }
    }

    onChange(value);
  };

  return React__default.createElement("select", {
    multiple: true,
    onChange: handleChange,
    value: value || []
  }, React__default.createElement("option", {
    value: '',
    disabled: true
  }, "Select your options"), options.map(function (opt) {
    return React__default.createElement("option", {
      key: opt[labelKey],
      value: opt[valueKey]
    }, opt[labelKey]);
  }));
}

var InputElements = {
  TextElement: TextElement,
  FileElement: FileElement,
  NumericElement: NumericElement,
  SelectElement: SelectElement,
  CheckboxElement: CheckboxElement,
  ButtonElement: ButtonElement,
  RadioElement: RadioElement,
  MultipleSelectElement: MultipleSelectElement
};

function ElementContainer(_ref) {
  var children = _ref.children;
  return React__default.createElement(React.Fragment, null, children);
}

function ElementWrapper(_ref) {
  var children = _ref.children,
      property = _ref.property;
  var type = property.type;
  var wrapperClass = (property.type !== 'object' && property.type !== 'array' ? 'ra-elem-wrapper ' : 'ra-elem-instance') + "\n        ra-elem-" + property.type + "     \n        " + (property.error ? 'ra-error' : '');

  var labelComponent = function labelComponent() {
    if (type !== 'array' && type !== 'object') {
      return React__default.createElement("label", {
        className: 'ra-form-label'
      }, property.title, property.isRequired && '*');
    } else {
      return React__default.createElement("div", {
        className: 'ra-form-title'
      }, property.title, property.isRequired && '*');
    }
  };

  return React__default.createElement("span", {
    className: wrapperClass
  }, labelComponent(), children, property.error && React__default.createElement("span", {
    className: 'ra-elem-error-text'
  }, typeof property.error !== 'boolean' && property.error[0].message));
}

var transformStringEntries = function transformStringEntries(registryEntries) {
  Object.entries(registryEntries).forEach(function (registryEntry) {
    if (typeof registryEntry[1].component === 'string') {
      if (InputElements[registryEntry[1].component]) {
        registryEntry[1].component = InputElements[registryEntry[1].component];
      } else {
        registryEntry[1].component = ElementContainer;
      }
    }
  });
};

var ComponentRegistry = /*#__PURE__*/function () {
  function ComponentRegistry(customRegistry, wrapper, exceptions) {
    var _this = this;

    if (customRegistry === void 0) {
      customRegistry = {};
    }

    if (wrapper === void 0) {
      wrapper = ElementWrapper;
    }

    if (exceptions === void 0) {
      exceptions = {
        paths: {},
        keys: {}
      };
    }

    this._registry = {
      "enum": {
        component: InputElements['SelectElement'],
        wrapper: wrapper
      },
      multipleEnum: {
        component: InputElements['MultipleSelectElement'],
        wrapper: wrapper
      },
      "boolean": {
        component: InputElements['CheckboxElement'],
        wrapper: wrapper
      },
      number: {
        component: InputElements['NumericElement'],
        wrapper: wrapper
      },
      integer: {
        component: InputElements['NumericElement'],
        wrapper: wrapper
      },
      string: {
        component: InputElements['TextElement'],
        wrapper: wrapper
      },
      file: {
        component: InputElements['FileElement'],
        wrapper: wrapper
      },
      button: {
        component: InputElements['ButtonElement'],
        wrapper: ElementContainer
      },
      addButton: {
        component: InputElements['ButtonElement'],
        wrapper: ElementContainer
      },
      removeButton: {
        component: InputElements['ButtonElement'],
        wrapper: ElementContainer
      }
    };
    Object.keys(customRegistry).forEach(function (key) {
      _this._registry["" + key] = customRegistry[key];
    });
    this._wrapper = wrapper;
    this._exceptions = Object.assign({
      paths: {},
      keys: {}
    }, exceptions);
    transformStringEntries(this._registry);
    transformStringEntries(this._exceptions.paths);
    transformStringEntries(this._exceptions.keys);
  }

  var _proto = ComponentRegistry.prototype;

  _proto.getComponent = function getComponent(property, itemValue, handleChange, children) {
    if (children === void 0) {
      children = null;
    }

    var props = {
      property: property,
      value: itemValue,
      onChange: handleChange,
      children: children
    };
    var pathException = property.path && this._exceptions.paths[property.path];

    var keyException = property.path && this._exceptions.keys[property.path.substr(property.path.lastIndexOf('.') + 1)];

    var Component = pathException && pathException.component || keyException && keyException.component || this._registry[property.registryKey] && this._registry[property.registryKey].component || ElementContainer;
    var Wrapper = pathException && pathException.wrapper || keyException && keyException.wrapper || this._registry[property.registryKey] && this._registry[property.registryKey].wrapper || this._wrapper;
    return React__default.createElement(Wrapper, Object.assign({}, props), React__default.createElement(Component, Object.assign({}, props)));
  };

  return ComponentRegistry;
}();

var formatters = {
  'required': function required(error) {
    return 'Field is required';
  },
  'minLength': function minLength(error) {
    var params = error.params;
    return "Field must not exceed " + params.limit + " characters";
  },
  'maxLength': function maxLength(error) {
    var params = error.params;
    return "Field must bet at least " + params.limit + " characters";
  },
  'pattern': function pattern(error) {
    var params = error.params;
    return "Field does not match pattern (" + params.pattern + ")";
  },
  'minimum': function minimum(error) {
    var params = error.params;
    return "Value should be at least " + params.limit;
  },
  'maximum': function maximum(error) {
    var params = error.params;
    return "Value should be at most " + params.limit;
  },
  'exclusiveMinimum': function exclusiveMinimum(error) {
    var params = error.params;
    return "Value should be greater than " + params.limit;
  },
  'exclusiveMaximum': function exclusiveMaximum(error) {
    var params = error.params;
    return "Value should be lower than " + params.limit;
  },
  'minItems': function minItems(error) {
    var params = error.params;
    return "Should not have fewer than " + params.limit + " items";
  },
  'uniqueItems': function uniqueItems(error) {
    return 'Should not contain duplicate items';
  }
};
function formatErrors(errors, customFn) {
  if (errors) {
    errors.forEach(function (error) {
      if (customFn) {
        customFn(error);
      } else {
        var keyword = error.keyword;
        var formatter = formatters[keyword];

        if (formatter) {
          error.message = formatter(error);
        }
      }
    });
  }

  return errors;
}

var _$1 = require('lodash');

var SchemaForm = function SchemaForm(_ref) {
  var schema = _ref.schema,
      _ref$root = _ref.root,
      root = _ref$root === void 0 ? schema : _ref$root,
      _ref$wrapper = _ref.wrapper,
      wrapper = _ref$wrapper === void 0 ? ElementWrapper : _ref$wrapper,
      _ref$parentChange = _ref.parentChange,
      parentChange = _ref$parentChange === void 0 ? null : _ref$parentChange,
      className = _ref.className,
      _ref$data = _ref.data,
      data = _ref$data === void 0 ? {} : _ref$data,
      _ref$config = _ref.config,
      config = _ref$config === void 0 ? null : _ref$config,
      _ref$onSubmit = _ref.onSubmit,
      onSubmit = _ref$onSubmit === void 0 ? function () {} : _ref$onSubmit,
      _ref$errorFormatter = _ref.errorFormatter,
      errorFormatter = _ref$errorFormatter === void 0 ? null : _ref$errorFormatter,
      _ref$path = _ref.path,
      path = _ref$path === void 0 ? '' : _ref$path,
      _ref$errors = _ref.errors,
      parentErrors = _ref$errors === void 0 ? null : _ref$errors;

  if (!schema) {
    throw new Error('schema must be provided to the SchemaForm component');
  }

  var _useState = React.useState(null),
      currentSchema = _useState[0],
      setCurrentSchema = _useState[1];

  var _useState2 = React.useState(Object.assign({}, {
    data: data,
    childPath: null
  })),
      obj = _useState2[0],
      setObj = _useState2[1];

  var _useState3 = React.useState(Object.keys(schema.properties || {})),
      keys = _useState3[0],
      setKeys = _useState3[1];

  var _useState4 = React.useState(function () {
    return parentChange ? null : new UISchema(schema);
  }),
      instance = _useState4[0];

  var _useState5 = React.useState(function () {
    return new ComponentRegistry(config && config.registry ? config.registry : {}, wrapper, config && config.exceptions ? config.exceptions : {
      paths: {},
      keys: {}
    });
  }),
      registry = _useState5[0];

  var _useState6 = React.useState([]),
      errors = _useState6[0],
      setErrors = _useState6[1];

  var _useState7 = React.useState(function () {
    var data = getConditionals(schema);
    return {
      data: data,
      lastEvaluations: ''
    };
  }),
      conditionals = _useState7[0];

  var removeObjPath = function removeObjPath(path, obj) {
    var prop = path[0];

    if (path.length > 1) {
      prop && removeObjPath(path.slice(1), obj ? obj[prop] : null);

      if (prop && obj && obj[prop] && Object.keys(obj[prop]).length === 0) {
        delete obj[prop];
      }
    } else {
      if (obj && prop && obj[prop] != undefined) {
        delete obj[prop];
      }
    }
  };

  var removeProperties = function removeProperties(currentSchema, baseSchema, nestedPath) {
    if (isObject(currentSchema) && isObject(baseSchema)) {
      if (currentSchema.$ref !== undefined) {
        var def = currentSchema.$ref.substr(currentSchema.$ref.lastIndexOf('/') + 1);
        root && root.definitions[def] && addProperties(currentSchema, root.definitions[def]);
      }

      for (var key in baseSchema) {
        if (!currentSchema[key]) {
          handleParentChange(key)(undefined, nestedPath + "." + key, nestedPath + "." + key);
        } else {
          removeProperties(currentSchema[key], baseSchema[key], key !== SCHEMA_KEYWORDS.PROPERTIES ? nestedPath + "." + key : nestedPath);
        }
      }
    }
  };

  var removeData = function removeData(schema, currentData) {
    if (isObject(schema) && isObject(currentData)) {
      if (schema.$ref !== undefined) {
        var def = schema.$ref.substr(schema.$ref.lastIndexOf('/') + 1);
        root && root.definitions[def] && addProperties(schema, root.definitions[def]);
      }

      for (var key in currentData) {
        if (schema.properties && schema.properties[key] === undefined) {
          delete currentData[key];
        } else {
          removeData(schema.properties && schema.properties[key], currentData[key]);

          if (isObject(currentData[key]) && Object.keys(currentData[key]).length === 0) {
            delete currentData[key];
          }
        }
      }
    }
  };

  var checkConditionals = function checkConditionals(actualSchema) {
    if (conditionals.data.length) {
      (function () {
        var lastEvaluation = '',
            currentEvaluation;

        var newSchema = _$1.cloneDeep(schema);

        var newData = _$1.cloneDeep(obj.data);

        var lastEvaluations = '';

        while (lastEvaluation !== currentEvaluation) {
          currentEvaluation = lastEvaluation;
          lastEvaluation = '';
          conditionals.data.forEach(function (conditional) {
            try {
              var evalCondition = eval(conditional.compiled)(newData);

              if (evalCondition) {
                addProperties(newSchema, conditional.then);
                newData = _$1.cloneDeep(obj.data);
                removeData(newSchema, newData);
                lastEvaluation += '1';
              } else {
                addProperties(newSchema, conditional["else"] || {});
                newData = _$1.cloneDeep(obj.data);
                removeData(newSchema, newData);
                lastEvaluation += '2';
              }
            } catch (err) {
              // property does not exist on data;
              lastEvaluation += '0';
            }
          });
          lastEvaluations += lastEvaluation;
        }

        if (lastEvaluations !== conditionals.lastEvaluations) {
          removeProperties(newSchema, actualSchema, '');
          setCurrentSchema(newSchema);
          setKeys(Object.keys(newSchema.properties || {}));
          conditionals.lastEvaluations = lastEvaluations;
        }
      })();
    }
  };

  var handleParentChange = function handleParentChange(key) {
    return function (value, childPath, nestedPath) {
      if (nestedPath) {
        setObj(function (prevObj) {
          var newObj = Object.assign({}, _extends({}, prevObj));
          removeObjPath(nestedPath.substr(1).split('.'), newObj.data);
          return newObj;
        });
      } else {
        setObj(function (prevObj) {
          var _extends2;

          var newValue = Object.assign({
            childPath: childPath
          }, {
            data: _extends({}, prevObj.data, (_extends2 = {}, _extends2[key] = value, _extends2))
          });

          if (value === undefined || value === '' || value && value.constructor === Array && value.length === 0) {
            delete newValue.data[key];
          }

          return newValue;
        });
      }
    };
  };

  var handleSubmit = function handleSubmit() {
    var result = instance.validate(obj.data);
    var errors = result || !instance.validator.errors ? [] : instance.validator.errors;
    errors.forEach(function (err, index, object) {
      if (err.keyword === SCHEMA_KEYWORDS.IF) {
        object.splice(index, 1);
      } else if (err.params && err.params.missingProperty) {
        err.dataPath += "." + err.params.missingProperty;
      }
    });
    var formattedErrors = formatErrors(errors, errorFormatter);
    setErrors(formattedErrors);
    onSubmit(obj.data, formattedErrors);
  };

  var getErrors = function getErrors(path) {
    var errArr = [].concat(errors, parentErrors || []);
    var result = errArr.filter(function (err) {
      return err.dataPath === path;
    });

    if (result && result.length === 0) {
      result = false;
    }

    return result;
  };

  React.useEffect(function () {
    setCurrentSchema(_$1.cloneDeep(schema));
    setKeys(Object.keys(schema.properties || {}));
  }, [schema]);
  React.useEffect(function () {
    checkConditionals(currentSchema || schema);

    if (parentChange && obj.childPath) {
      parentChange(obj.data, obj.childPath);
    } else {
      setErrors(errors.filter(function (item) {
        return item.dataPath !== obj.childPath;
      }));
    }
  }, [obj]);
  return React__default.createElement("span", {
    className: className + " ra-schema-form"
  }, currentSchema && keys.map(function (key) {
    var childPath = path + "." + key;
    var prop = currentSchema.properties[key];
    return React__default.createElement(FormElement, {
      root: root,
      key: key,
      config: config,
      wrapper: wrapper,
      error: getErrors(childPath),
      errors: parentErrors || errors,
      value: obj.data ? obj.data[key] : undefined,
      schema: prop,
      path: childPath,
      parentSchema: currentSchema,
      handleParentChange: handleParentChange(key),
      registry: registry
    });
  }), !parentChange && registry.getComponent({
    registryKey: SCHEMA_KEYWORDS.BUTTON,
    className: 'ra-submit-button'
  }, 'Submit', handleSubmit));
};

exports.SchemaForm = SchemaForm;
//# sourceMappingURL=index.js.map
